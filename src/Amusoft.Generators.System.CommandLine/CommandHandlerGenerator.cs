using System.Linq;
using Amusoft.Generators.System.CommandLine.Attributes;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using NotImplementedException = System.NotImplementedException;

namespace Amusoft.Generators.System.CommandLine;

[Generator]
internal class CommandHandlerGenerator : ISourceGenerator
{
	public void Initialize(GeneratorInitializationContext context)
	{
	}

	public void Execute(GeneratorExecutionContext context)
	{
		foreach (var syntaxTree in context.Compilation.SyntaxTrees)
		{
			var root = syntaxTree.GetRoot(context.CancellationToken);
			foreach (var classDeclarationSyntax in root.DescendantNodes(_ => true).OfType<ClassDeclarationSyntax>())
			{
				var semanticModel = context.Compilation.GetSemanticModel(syntaxTree);
				var isCandidate = IsClassCandidate(classDeclarationSyntax, semanticModel);
				if (isCandidate)
				{
					AppendGeneratorCode(context, classDeclarationSyntax);
				}
			}
		}

		// // Find the main method
		// var mainMethod = context.Compilation.GetEntryPoint(context.CancellationToken);
		// 		// Build up the source code
		// 		string source = $@"// <auto-generated/>
		// using System;
		//
		// namespace {mainMethod.ContainingNamespace.ToDisplayString()}
		// {{
		//     public partial class {mainMethod.ContainingType.Name}
		//     {{
		//         static partial void HelloFrom(string name) =>
		//             Console.WriteLine($""Generator says this: Hi from '{{name}}'"");
		//     }}
		// }}
		// ";
		// 		var typeName = mainMethod.ContainingType.Name;
		//
		// 		// Add the source code to the compilation
		// 		context.AddSource($"{typeName}.g.cs", source);
	}

	private void AppendGeneratorCode(GeneratorExecutionContext context, ClassDeclarationSyntax classDeclarationSyntax)
	{
		var source = @$"""
namespace Amusoft.Generators.System.CommandLine.UnitTests.TestResources;

{classDeclarationSyntax.Modifiers} {classDeclarationSyntax.Identifier}  
{{
	public void Hello(){{}}
}}
		""";

		context.AddSource($"{classDeclarationSyntax.Identifier.Text}.g.cs", source);
	}

	private static bool IsClassCandidate(ClassDeclarationSyntax classDeclarationSyntax, SemanticModel semanticModel)
	{
		var classSymbol = semanticModel.GetDeclaredSymbol(classDeclarationSyntax);
		var attributesData = classSymbol.GetAttributes();
		var handlerAttributeTypeSymbol = semanticModel.Compilation.GetTypeByMetadataName(typeof(GenerateCommandHandlerAttribute).FullName);
		var match = attributesData.Any(d => d.AttributeClass.Equals(handlerAttributeTypeSymbol));
		if (attributesData.Length > 0 && attributesData[0].AttributeClass.Kind == SymbolKind.ErrorType)
		{
			var a = "error";
		}
		return match;
		var attributes = classDeclarationSyntax.AttributeLists.SelectMany(d => d.Attributes);
		foreach (var attributeSyntax in attributes)
		{
			var symbol = semanticModel.GetSymbolInfo(attributeSyntax);
			if (symbol.CandidateSymbols.Length > 0 && symbol.CandidateSymbols.Any(d=> d.MetadataName == typeof(GenerateCommandHandlerAttribute).FullName))
				return true;
		}

		return false;
	}
}