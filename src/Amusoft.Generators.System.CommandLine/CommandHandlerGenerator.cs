using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Reflection.Metadata;
using System.Text;
using Amusoft.Generators.System.CommandLine.Attributes;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Amusoft.Generators.System.CommandLine;

[Generator]
internal class CommandHandlerGenerator : ISourceGenerator
{
	public void Initialize(GeneratorInitializationContext context)
	{
	}

	public void Execute(GeneratorExecutionContext context)
	{
		foreach (var syntaxTree in context.Compilation.SyntaxTrees)
		{
			var root = syntaxTree.GetRoot(context.CancellationToken);
			foreach (var outerClass in ClassesWhichImplementCommand(root))
			{
				var semanticModel = context.Compilation.GetSemanticModel(syntaxTree);
				if (TryGetCandidate(semanticModel, outerClass, out var innerClass))
				{
					AppendGeneratorCode(context, semanticModel, outerClass, innerClass);
				}
			}
		}

		// // Find the main method
		// var mainMethod = context.Compilation.GetEntryPoint(context.CancellationToken);
		// 		// Build up the source code
		// 		string source = $@"// <auto-generated/>
		// using System;
		//
		// namespace {mainMethod.ContainingNamespace.ToDisplayString()}
		// {{
		//     public partial class {mainMethod.ContainingType.Name}
		//     {{
		//         static partial void HelloFrom(string name) =>
		//             Console.WriteLine($""Generator says this: Hi from '{{name}}'"");
		//     }}
		// }}
		// ";
		// 		var typeName = mainMethod.ContainingType.Name;
		//
		// 		// Add the source code to the compilation
		// 		context.AddSource($"{typeName}.g.cs", source);
	}

	private static IEnumerable<ClassDeclarationSyntax> ClassesWhichImplementCommand(SyntaxNode root)
	{
		return root.DescendantNodes(_ => true).OfType<ClassDeclarationSyntax>();
	}

	private void AppendGeneratorCode(GeneratorExecutionContext context, SemanticModel semanticModel, ClassDeclarationSyntax outerClass, ClassDeclarationSyntax innerClass)
	{
		if (outerClass == null) throw new ArgumentNullException(nameof(outerClass));
		if (innerClass == null) throw new ArgumentNullException(nameof(innerClass));

		var outerClassSymbol = semanticModel.GetDeclaredSymbol(outerClass);
		if (outerClassSymbol is null)
			return;

		var targetNamespace = outerClassSymbol.ContainingNamespace.ToDisplayString();
		var constructorServiceList = GetConstructorServices(semanticModel, innerClass)
			.Select(d => $"host.Services.GetRequiredService<{d}>()");
		var sb = new StringBuilder();
		sb.Append(
		$$"""
		// <auto-generated/>
		using System.CommandLine;
		using System.CommandLine.Invocation;
		using System.Threading.Tasks;
		using Amusoft.Generators.System.CommandLine.Attributes;
		using Microsoft.Extensions.DependencyInjection;
		using Microsoft.Extensions.Hosting;

		namespace {{targetNamespace}};	
		
		{{outerClass.Modifiers}} {{outerClass.Identifier}}
		{
			private {{innerClass.Identifier.Text}} _handler;

			private void BindHandler()
			{
				if (_handler is null)
					return;

				this.SetHandler(async (context) =>
				{
					var host = context.BindingContext.GetRequiredService<IHost>();
					_handler = new {{innerClass.Identifier.Text}}({{string.Join(",", constructorServiceList)}});
	
		""");

		sb.Append(
		$$"""
					var p1 = context.ParseResult.GetValueForOption(OptionOne);
					var p2 = context.ParseResult.GetValueForOption(OptionTwo);
					var p3 = context.ParseResult.GetValueForArgument(ArgumentOne);

					await _handler.ExecuteAsync(context, p1, p2, p3);
				});
			}

			{{innerClass.Modifiers}} {{innerClass.Identifier.Text}} : InvokerBase
			{
			}
		
			public abstract class InvokerBase
			{
				public virtual Task ExecuteAsync(InvocationContext context, string optionOne, int optionTwo, int argumentOne) => Task.CompletedTask;				
			}
		}
		""");

		context.AddSource($"{outerClass.Identifier.Text}.g.cs", sb.ToString());
	}

	private string[] GetConstructorServices(SemanticModel semanticModel, ClassDeclarationSyntax innerClass)
	{
		var constructorSyntax = innerClass.ChildNodes().OfType<ConstructorDeclarationSyntax>()
			.FirstOrDefault();
		if (constructorSyntax is null)
			return Array.Empty<string>();

		if (constructorSyntax.ParameterList is {Parameters: { } parameters})
		{
			var parameterTypes = parameters.Select(parameter =>
			{
				if (parameter.Type != null && semanticModel.GetSymbolInfo(parameter.Type) is {Symbol: { } symbol})
					return $"{symbol.ContainingNamespace.ToDisplayString()}.{symbol.ToDisplayString()}";

				return string.Empty;
			});

			return parameterTypes.ToArray();
		}

		return Array.Empty<string>();
	}

	private static bool TryGetCandidate(SemanticModel semanticModel, ClassDeclarationSyntax parentClass, [NotNullWhen(true)] out ClassDeclarationSyntax? implementorChildClass)
	{
		implementorChildClass = default;
		if (parentClass.BaseList is null)
			return false;

		var parentSymbol = semanticModel.GetDeclaredSymbol(parentClass);
		var handlerAttributeTypeSymbol = semanticModel.Compilation.GetTypeByMetadataName(typeof(GenerateCommandHandlerAttribute).FullName);
		var commandSymbol = semanticModel.Compilation.GetTypeByMetadataName(typeof(global::System.CommandLine.Command).FullName);

		var inheritsCommand = parentClass.BaseList.Types.Any(baseType =>
		{
			if (semanticModel.GetSymbolInfo(baseType.Type) is {Symbol : { } symbol})
				return symbol.Equals(commandSymbol, SymbolEqualityComparer.Default);
			return false;
		});

		if (!inheritsCommand)
			return false;

		implementorChildClass = parentClass.ChildNodes()
			.OfType<ClassDeclarationSyntax>()
			.Where(syntax =>
			{
				var classSymbol = semanticModel.GetDeclaredSymbol(syntax);
				if (classSymbol is null)
					return false;

				return classSymbol.GetAttributes().Any(attributeData =>
				{
					if (attributeData is {AttributeClass: { } attributeClass})
						return attributeClass.Equals(handlerAttributeTypeSymbol, SymbolEqualityComparer.Default);
					return true;
				});
			})
			.FirstOrDefault();

		return implementorChildClass != null;
	}
}